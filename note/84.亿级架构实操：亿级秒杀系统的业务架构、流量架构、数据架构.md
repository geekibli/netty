# 亿级架构实操：亿级秒杀系统的业务架构、流量架构、数据架构

## 秒杀场景的流量特点

1. 巨大的突发流量
2. 巨大的后端无效流量


##  商品维度限流

网关层对除了userId做限流外，还要从商品skuid维度限流

> 在实际访问量超过预估访问量是，整体限流可以起到保护作用，避免系统被压垮

一旦秒杀开始，实际秒杀成功的用户只是库存的数量，在库存没有之后，将前端的秒杀入口关闭。


## 写流量处理

**诀窍**

1. 有效流量过滤，过滤出有效请求
2. 有效流量削峰，有效请求，达到或者超出下一层的能力瓶颈，同步处理，变成（降级为）异步处理
3. 有效流量限流，1000qps，接入层，服务层，数据库

## 秒杀两阶段操作

1. 第一阶段为有效流量的锁定，将有效的流量识别出来，过滤掉无效的流量
2. 第二阶段为有效流量落地，将有效流量，落地到服务层

![](https://oscimg.oschina.net/oscnet/up-ace9fccb61eddeeb5f984bb3bd9c5373c4d.png)


## 异步削峰和限流保护

### 异步削峰

秒杀系统是一个高并发系统，采用异步处理模式可以极大的提高系统并发量，其实异步处理就是削峰的一种实现方式。

> 场景， 10w人抢10000个商品

两段式操作，参考一下：

1. 第一阶段为有效流量锁定，将有效的流量识别出来，过滤掉无效的流量
2. 第二阶段为有效流量落地，将有效流量，落地到服务层

有效流量也很大，比如100w人抢10w商品，如何提升下单阶段的性能呢？

消息队列削峰，其集群吞吐量可以达到100wqps。

![](https://oscimg.oschina.net/oscnet/up-2d75601dcee303e0a70b85076c49c3c4bf4.png)


### 限流保护

超出了用户的忍耐度，或者超出系统的承受能力。

可以使用redis分布式限流或者sentinel进行限流。



## 缓存层 （分布式缓存)

### 读请求：商品信息提前缓存

参加秒杀活动的商品是提前预知的，可以将参加秒杀的商品信息实现缓存到redis等缓存系统中，这样可以大大的提升系统的吞吐量，减少关系型数据库的读写压力。

为了极致的提高速度，最好是推送到ng的本地缓存

这中间的数据一致性，消息队列的作用，非常大


### 三级缓存

为了解决以上可能出现的问题，让缓存层更稳定，健壮，我们可以引入三级缓存架构。


1. 一级缓存为本地缓存，或者进程内的缓存（如同时指出Ehcache2.X, Ehcache3.x，Guava，Caffeine）速度快，进程内可用
2. 二级缓存为集中式缓存，如redis，可同时为多节点提供服务
3. 三级缓存为接入层Nginx本地缓存，速度快，进程内可用


#### 原则

尽量命中Ng缓存，最坏也要命中redis分布式缓存



## 秒杀的功能分离

在秒杀系统中，这里需要区分为突发流量型和平缓流量型的功能，从业务上把秒杀和日常的售卖区分开来，对突发流量的功能做好隔离。

![](https://oscimg.oschina.net/oscnet/up-6986deee5ee90dacea8b1b0e571a57008c0.png)

把秒杀作为营销活动，要参与秒杀的商品需要提前报名参加活动，这样我们就能提前知道哪些商家哪些商品要参与秒杀，对应于秒杀系统的核心功能，比如，商品详情，下单等。


## 系统架构（分层）

1. 客户端： 客户端层是浏览器或者手机应用app
2. 接入层：系统入口，负载均衡，反向代理
3. 服务层：实现核心应用逻辑，返回html或者json
4. 缓存层：缓存加速访问存储
5. 数据库层：结构化db和异构db
6. 中间件：zk，xxl-job,rocketmq

