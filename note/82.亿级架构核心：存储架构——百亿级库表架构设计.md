# 亿级架构核心：存储架构——百亿级库表架构设计

按照每天1000w的数据量，2年保持稳定的要求，进行表的数据量规划。

> 两年总量是73亿，假设没张表500w的数据量，表的数量在1460张。
> 如果按照单表692w的数据量，表的数量是1024


![](https://oscimg.oschina.net/oscnet/up-7fd2597d1c10ea196d7fca4b890d4cb62b8.png)

## 库的数量规划

按照qps为5w的要求，进行库的规划

> 每个库正常承载的写入并发量是1500，那么32个库就可以承载 32 * 1500 = 48000的写并发。

悲观一些，如果每秒写入超过5W qps，可以通过MQ削峰+批写入的降级策略，MQ的写入吞吐量可以轻松达到10W级别。



**总的规划**  
 
利用32 * 32来分库分表，即分成32个库，每个库中一个表分成32张表，一共就是1-24张表。

根据某个id先32取模路由到库，在根据32取模路由到库中的表。



## 分库分表技术选型

![](https://oscimg.oschina.net/oscnet/up-e4d4c69792c9dd3fd6f1cfcd143b89e0631.png)


### mycat

基于cobar改造的，属于proxy层方案。支持的功能非常完善，而且目前是非常火的数据库中间件，而且社区比较活跃。

#### 好处

和业务代码耦合度很低，只需做一些配置，介入成本低

#### 缺点

1. 性能问题，这种代理中间件需要单独部署，所以从调用链上有多了一层
2. 分库分表逻辑完全由代理层中间件管理，对于程序员完全是一个黑盒，一点代理本身出现问题，会导致无法查询和存储相关业务数据，引发灾难性的后果。


### 客户端分片

利用sharding-jdbc，TDDL等以jar包的方式呈现轻量级组件分库分表。


#### TDDL

淘宝团队开发，属于client层方案，支持基本的crud语法和读写分离，但是不支持json，多表查询等语法。

#### sharding-jdbc

当当开源的。属于client层方案。

支持读写分离，分库分表，分布式id生成，柔性事务（最大努力送达，TCC事务），而且确实使用的公司会比较多一些。

缺点是会有一定代码开开发工作量，对业务有一些侵入性，好处是对于程序员透明，程序员对分库分表逻辑把控会更强，一旦发生故障，排查问题也会比较容易。


#### 云数据库

比如阿里云的PolarDB-X。

一旦出现问题，主动性就给到了服务提供商